From 4ee8f2e840c9d000bbaa32d9128dfa27556a3051 Mon Sep 17 00:00:00 2001
From: Haoran Wang <elven.wang@nxp.com>
Date: Mon, 28 Aug 2023 20:55:28 +0800
Subject: [PATCH] Apply IW612 change to openthread

Refer changes from: otpatches-040-0f7e849

Upstream-Status: Inappropriate [NXP-specific]

Signed-off-by: Haoran Wang <elven.wang@nxp.com>
---
 include/openthread/platform/radio.h           |  60 ++
 src/core/config/mac.h                         |   2 +-
 src/core/config/misc.h                        |   2 +-
 src/core/thread/csl_tx_scheduler.cpp          |   1 +
 src/lib/spinel/multi_frame_buffer.hpp         |   2 +-
 src/lib/spinel/radio_spinel.hpp               |  72 +-
 src/lib/spinel/radio_spinel_impl.hpp          | 133 +++-
 src/lib/spinel/spinel.h                       |  10 +
 src/lib/spinel/spinel_interface.hpp           |   2 +-
 src/ncp/ncp_spi.cpp                           |   4 +-
 src/posix/main.c                              |  17 +
 src/posix/platform/daemon.cpp                 | 629 ++++++++++++++++++
 src/posix/platform/hdlc_interface.cpp         |   6 +-
 src/posix/platform/hdlc_interface.hpp         |  11 +-
 .../include/openthread/openthread-system.h    |   2 +-
 .../platform/openthread-core-posix-config.h   |   2 +-
 src/posix/platform/radio.cpp                  |  61 ++
 src/posix/platform/spi_interface.cpp          |  70 +-
 src/posix/platform/spi_interface.hpp          |  10 +-
 src/posix/platform/system.cpp                 |   2 +
 20 files changed, 1063 insertions(+), 35 deletions(-)

diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
index bb7ef0c3d..9c18a82d1 100644
--- a/include/openthread/platform/radio.h
+++ b/include/openthread/platform/radio.h
@@ -420,6 +420,17 @@ typedef struct otLinkMetrics
     bool mReserved : 1;   ///< Reserved, this is for reference device.
 } otLinkMetrics;
 
+/**
+ * This structure represents different CCA mode configurations before Tx.
+ */
+typedef struct otCCAModeConfig
+{
+    uint8_t mCcaMode;          ///< CCA Mode type [CCA1=0x01, CCA2=0x02, CCA3=0x03[CCA1 AND CCA2], CCA3=0x04[CCA1 OR CCA2], NoCCA=0xFF.
+    uint8_t mCca1Threshold;    ///< Energy threshold for CCA Mode1.
+    uint8_t mCca2CorrThreshold;    ///< CCA Mode 2 Correlation Threshold.
+    uint8_t mCca2MinNumOfCorrTh;    ///< CCA Mode 2 Threshold Number of Correlation Peaks.
+} otCCAModeConfig;
+
 /**
  * @}
  *
@@ -675,6 +686,18 @@ uint64_t otPlatRadioGetNow(otInstance *aInstance);
  */
 uint32_t otPlatRadioGetBusSpeed(otInstance *aInstance);
 
+/**
+ * Set the bus speed in bits/second between the host and the radio chip.
+ *
+ * @param[in]   aInstance    A pointer to an OpenThread instance.
+ * @param[in]   aSpeed       The SPI Bus Speed request.
+ *
+ * @returns The bus speed in bits/second between the host and the radio chip.
+ *          Return 0 when the MAC and above layer and Radio layer resides on the same chip.
+ *
+ */
+otError otPlatRadioSetBusSpeed(otInstance *aInstance, uint32_t aSpeed);
+
 /**
  * @}
  *
@@ -1280,11 +1303,48 @@ extern otError otPlatRadioGetRawPowerSetting(otInstance *aInstance,
  * @}
  *
  */
+void otPlatRadioSetIRCmd(otInstance *aInstance);
+
+/**
+ * @}
+ *
+ */
+void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode);
+
+/**
+ * @}
+ *
+ */
+otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64);
+
+/**
+ * @}
+ *
+ */
+otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
+/**
+ * @}
+ *
+ */
+otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit);
+
+/**
+ * @}
+ *
+ */
+otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut);
+
+/**
+ * @}
+ *
+ */
+otError otPlatRadioCcaConfigValue(otInstance *aInstance, otCCAModeConfig *aCcaConfig, uint8_t aSetValue);
 
 /**
  * @}
  *
  */
+otError otPlatRadioGetFwVersionString(otInstance *aInstance, const char *fwVersion, uint8_t fwVersionLen);
 
 #ifdef __cplusplus
 } // end of extern "C"
diff --git a/src/core/config/mac.h b/src/core/config/mac.h
index 2694e0dc8..ed1cdc06d 100644
--- a/src/core/config/mac.h
+++ b/src/core/config/mac.h
@@ -206,7 +206,7 @@
  *
  */
 #ifndef OPENTHREAD_CONFIG_MAC_CSL_REQUEST_AHEAD_US
-#define OPENTHREAD_CONFIG_MAC_CSL_REQUEST_AHEAD_US 2000
+#define OPENTHREAD_CONFIG_MAC_CSL_REQUEST_AHEAD_US 16000
 #endif
 
 /**
diff --git a/src/core/config/misc.h b/src/core/config/misc.h
index df9fd28fa..601bd1c03 100644
--- a/src/core/config/misc.h
+++ b/src/core/config/misc.h
@@ -180,7 +180,7 @@
  *
  */
 #ifndef OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS
-#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 44
+#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 200
 #endif
 
 /**
diff --git a/src/core/thread/csl_tx_scheduler.cpp b/src/core/thread/csl_tx_scheduler.cpp
index 45facec35..c963fde2b 100644
--- a/src/core/thread/csl_tx_scheduler.cpp
+++ b/src/core/thread/csl_tx_scheduler.cpp
@@ -169,6 +169,7 @@ uint32_t CslTxScheduler::GetNextCslTransmissionDelay(const Child &aChild,
 
     aDelayFromLastRx = static_cast<uint32_t>(nextTxWindow - aChild.GetLastRxTimestamp());
 
+    otLogInfoPlat("CSL radioNow = %lu, periodInUS = %hu,firstTXWindow = %lu, nextTxWindow = %lu, aDelayFromLastRx = %u, lastRxTimeStamp = %lu", radioNow, periodInUs, firstTxWindow, nextTxWindow, aDelayFromLastRx,aChild.GetLastRxTimestamp());
     return static_cast<uint32_t>(nextTxWindow - radioNow - aAheadUs);
 }
 
diff --git a/src/lib/spinel/multi_frame_buffer.hpp b/src/lib/spinel/multi_frame_buffer.hpp
index 2c90d9069..6939e28c8 100644
--- a/src/lib/spinel/multi_frame_buffer.hpp
+++ b/src/lib/spinel/multi_frame_buffer.hpp
@@ -375,7 +375,7 @@ public:
 
         aFrame = (aFrame == nullptr) ? mBuffer : aFrame + aLength;
 
-        if (aFrame != mWriteFrameStart)
+        if (aFrame < mWriteFrameStart) // there were issues when clearing the buffer, index was not properly reset
         {
             uint16_t totalLength = Encoding::LittleEndian::ReadUint16(aFrame + kHeaderTotalLengthOffset);
             uint16_t skipLength  = Encoding::LittleEndian::ReadUint16(aFrame + kHeaderSkipLengthOffset);
diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
index 7c32dbe07..78061b725 100644
--- a/src/lib/spinel/radio_spinel.hpp
+++ b/src/lib/spinel/radio_spinel.hpp
@@ -171,6 +171,67 @@ public:
      */
     otError GetIeeeEui64(uint8_t *aIeeeEui64);
 
+    /**
+     * This method sets the factory-assigned IEEE EUI-64 for this transceiver.
+     *
+     * @param[in]  aInstance   The OpenThread instance structure.
+     * @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.
+     *
+     * @retval  OT_ERROR_NONE               Succeeded.
+     * @retval  OT_ERROR_INVALID_STATE      Failed EUI64 is set by factory only except if OTP is not supported.
+     *
+     */
+    otError SetIeeeEui64(const otExtAddress &aIeeeEui64);
+
+    /**
+     * @brief Set the Tx Power Limit for 15.4
+     *
+     * @param txPowerLimit
+     * txPowerLimit (0 or higher than 22), No power backoff is applied
+     * txPowerLimit = 1 to 44, force TX power back off to txPowerLimit
+     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
+     *
+     * @return otError
+     */
+    otError SetTxPowerLimit(uint8_t txPowerLimit);
+
+    /**
+     * @brief Get the Tx Power Limit for 15.4
+     *
+     * @param &txPowerLimit
+     * will contain the value set in IWx12
+     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
+     *
+     * @return otError
+     */
+    otError GetTxPowerLimit(uint8_t &txPowerLimit);
+
+    /**
+     * @brief GetMfgChannel
+     * @param channel
+     * @return otError
+     */
+    otError MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut);
+
+    /**
+     * @brief Set / Get the CCA Mode Configuration Values
+     *
+     * @param &aCcaConfig
+     * will contain the CCA Configuration values of datatype otCCAModeConfig.
+     *
+     * @return otError
+     */
+    otError CcaConfigValue(otCCAModeConfig &aCcaConfig, uint8_t aSetValue);
+
+   /**
+    * This method returns the fw version string.
+    *
+    * @param[out] fwVersion
+    *
+    * @returns otError
+    */
+    otError GetFwVersion(const char *fwVersion, uint8_t fwVersionLen);
+
     /**
      * Sets the Extended Address for address filtering.
      *
@@ -766,7 +827,16 @@ public:
      * @returns   bus speed in bits/second.
      *
      */
-    uint32_t GetBusSpeed(void) const;
+    uint32_t GetBusSpeed(void);
+
+    /**
+     * This method sets the bus speed between the host and the radio.
+     *
+     * @retval  OT_ERROR_NONE           Successfully set the spi frequency.
+     * @retval  OT_ERROR_INVALID_ARGS   frequency is not in valid range.
+     *
+     */
+    otError SetBusSpeed(uint32_t aSpeed);
 
     /**
      * Sets the max transmit power.
diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
index 4d4fa06c5..76b67b328 100644
--- a/src/lib/spinel/radio_spinel_impl.hpp
+++ b/src/lib/spinel/radio_spinel_impl.hpp
@@ -1041,6 +1041,88 @@ template <typename InterfaceType> otError RadioSpinel<InterfaceType>::GetIeeeEui
     return OT_ERROR_NONE;
 }
 
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::SetIeeeEui64(const otExtAddress &aIeeeEui64)
+{
+    otExtAddress addr;
+    otError      error;
+
+    for (size_t i = 0; i < sizeof(addr); i++)
+    {
+        addr.m8[i] = aIeeeEui64.m8[sizeof(addr) - 1 - i];
+    }
+
+    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD, SPINEL_DATATYPE_EUI64_S, addr.m8));
+    mIeeeEui64 = aIeeeEui64;
+exit:
+    return error;
+}
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::SetTxPowerLimit(uint8_t txPowerLimit)
+{
+    otError error;
+    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
+
+exit:
+    return error;
+}
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::GetTxPowerLimit(uint8_t &txPowerLimit)
+{
+    otError error = Get(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, &txPowerLimit);
+    return error;
+}
+
+#define MAXBUFFERSIZE 16
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut)
+{
+    otError error;
+    uint8_t buffer[MAXBUFFERSIZE]; //temporary buffer used to be passed as arg of GetWithParam
+    spinel_ssize_t packed;
+
+    packed = spinel_datatype_pack(buffer, sizeof(buffer), SPINEL_DATATYPE_DATA_S, payload, payloadLenIn);
+    error = GetWithParam(SPINEL_CMD_VENDOR_NXP_MFG, buffer, static_cast<spinel_size_t>(packed), SPINEL_DATATYPE_DATA_S, payload, &payloadLenOut);
+
+    return error;
+}
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::CcaConfigValue(otCCAModeConfig &aCcaConfig, uint8_t aSetValue)
+{
+    otError error;
+    uint8_t aCcaMode, aCca1Threshold, aCca2CorrThreshold, aCca2MinNumOfCorrTh;
+
+    if(aSetValue)
+    {
+        error = Set(SPINEL_PROP_VENDOR_NXP_GET_SET_CCA_CONFIGURE_CMD, SPINEL_DATATYPE_STRUCT_S(SPINEL_DATATYPE_UINT8_S
+                    SPINEL_DATATYPE_UINT8_S SPINEL_DATATYPE_UINT8_S SPINEL_DATATYPE_UINT8_S), (&aCcaConfig)->mCcaMode,
+                    (&aCcaConfig)->mCca1Threshold, (&aCcaConfig)->mCca2CorrThreshold, (&aCcaConfig)->mCca2MinNumOfCorrTh);
+    }
+    else
+    {
+        error = Get(SPINEL_PROP_VENDOR_NXP_GET_SET_CCA_CONFIGURE_CMD, SPINEL_DATATYPE_STRUCT_S(SPINEL_DATATYPE_UINT8_S
+                    SPINEL_DATATYPE_UINT8_S SPINEL_DATATYPE_UINT8_S SPINEL_DATATYPE_UINT8_S), &aCcaMode, &aCca1Threshold,
+                    &aCca2CorrThreshold, &aCca2MinNumOfCorrTh);
+        (&aCcaConfig)->mCcaMode = aCcaMode;
+        (&aCcaConfig)->mCca1Threshold = aCca1Threshold;
+        (&aCcaConfig)->mCca2CorrThreshold = aCca2CorrThreshold;
+        (&aCcaConfig)->mCca2MinNumOfCorrTh = aCca2MinNumOfCorrTh;
+    }
+
+    return error;
+}
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::GetFwVersion(const char *fwVersion, uint8_t fwVersionLen)
+{
+    otError error = Get(SPINEL_PROP_VENDOR_NXP_GET_FW_VERSION_CMD, SPINEL_DATATYPE_UTF8_S, fwVersion, fwVersionLen);
+    return error;
+}
+
 template <typename InterfaceType>
 otError RadioSpinel<InterfaceType>::SetExtendedAddress(const otExtAddress &aExtAddress)
 {
@@ -1858,6 +1940,7 @@ template <typename InterfaceType> otError RadioSpinel<InterfaceType>::Enable(otI
     SuccessOrExit(error = Set(SPINEL_PROP_MAC_15_4_PANID, SPINEL_DATATYPE_UINT16_S, mPanId));
     SuccessOrExit(error = Set(SPINEL_PROP_MAC_15_4_SADDR, SPINEL_DATATYPE_UINT16_S, mShortAddress));
     SuccessOrExit(error = Get(SPINEL_PROP_PHY_RX_SENSITIVITY, SPINEL_DATATYPE_INT8_S, &mRxSensitivity));
+    SuccessOrExit(error = Set(SPINEL_PROP_PHY_TX_POWER, SPINEL_DATATYPE_INT8_S, mTransmitPower));
 
     mState = kStateSleep;
 
@@ -2010,12 +2093,44 @@ exit:
 
 template <typename InterfaceType> uint64_t RadioSpinel<InterfaceType>::GetNow(void)
 {
+
+    otLogDebgPlat("mIsTimeSynced = %d, otPlatTimeGet = %lu, mRadioTimeOffset = %lu",mIsTimeSynced, otPlatTimeGet(), mRadioTimeOffset);
     return (mIsTimeSynced) ? (otPlatTimeGet() + mRadioTimeOffset) : UINT64_MAX;
 }
 
-template <typename InterfaceType> uint32_t RadioSpinel<InterfaceType>::GetBusSpeed(void) const
+template <typename InterfaceType> uint32_t RadioSpinel<InterfaceType>::GetBusSpeed(void)
+{
+    uint32_t  speed  = 0;
+    Get(SPINEL_PROP_VENDOR_NXP_GET_SET_RCP_FREQUENCY_CMD, SPINEL_DATATYPE_UINT32_S, &speed);
+    return speed;
+}
+
+#ifndef MIN
+#define MIN( x, y ) ( ( x ) < ( y ) ? ( x ) : ( y ) )
+#endif
+
+template <typename InterfaceType>
+otError RadioSpinel<InterfaceType>::SetBusSpeed(uint32_t speed)
 {
-    return mSpinelInterface.GetBusSpeed();
+    uint32_t current = mSpinelInterface.GetBusSpeed();
+    otError  error = OT_ERROR_NONE;
+
+    mSpinelInterface.SetBusSpeed(MIN(current, speed));
+
+    error = Set(SPINEL_PROP_VENDOR_NXP_GET_SET_RCP_FREQUENCY_CMD, SPINEL_DATATYPE_UINT32_S, speed);
+
+    if( error == OT_ERROR_NONE )
+    {
+        // Apply new frequency
+        mSpinelInterface.SetBusSpeed(speed);
+    }
+    else
+    {
+        // Back to old frequency
+        mSpinelInterface.SetBusSpeed(current);
+    }
+
+    return error;
 }
 
 template <typename InterfaceType> void RadioSpinel<InterfaceType>::HandleRcpUnexpectedReset(spinel_status_t aStatus)
@@ -2087,6 +2202,9 @@ template <typename InterfaceType> void RadioSpinel<InterfaceType>::RecoverFromRc
     mIsTimeSynced = false;
 
     ResetRcp(mResetRadioOnStartup);
+    // this clear is necessary in case the RCP has sent messages between disable and reset
+    mRxFrameBuffer.Clear();
+
     SuccessOrDie(Set(SPINEL_PROP_PHY_ENABLED, SPINEL_DATATYPE_BOOL_S, true));
     mState = kStateSleep;
 
@@ -2143,9 +2261,14 @@ template <typename InterfaceType> void RadioSpinel<InterfaceType>::RestoreProper
 
     if (mInstance != nullptr)
     {
-        SuccessOrDie(static_cast<Instance *>(mInstance)->template Get<Settings>().Read(networkInfo));
-        SuccessOrDie(
-            Set(SPINEL_PROP_RCP_MAC_FRAME_COUNTER, SPINEL_DATATYPE_UINT32_S, networkInfo.GetMacFrameCounter()));
+        // if the device is not attached, it means that the settings could be not set
+        // and frame counter has no point of being set.
+        if(static_cast<Instance *>(mInstance)->template Get<Mle::MleRouter>().IsAttached())
+        {
+            SuccessOrDie(static_cast<Instance *>(mInstance)->template Get<Settings>().Read(networkInfo));
+            SuccessOrDie(
+                Set(SPINEL_PROP_RCP_MAC_FRAME_COUNTER, SPINEL_DATATYPE_UINT32_S, networkInfo.GetMacFrameCounter()));
+        }
     }
 
     for (int i = 0; i < mSrcMatchShortEntryCount; ++i)
diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
index c251eb1db..7831f0525 100644
--- a/src/lib/spinel/spinel.h
+++ b/src/lib/spinel/spinel.h
@@ -4866,6 +4866,16 @@ enum
     SPINEL_PROP_NEST__END = 0x3C00,
 
     SPINEL_PROP_VENDOR__BEGIN = 0x3C00,
+
+    SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
+    SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+    SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
+    SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
+    SPINEL_PROP_VENDOR_NXP_GET_SET_CCA_CONFIGURE_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10C),
+    SPINEL_PROP_VENDOR_NXP_GET_FW_VERSION_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10D),
+    SPINEL_PROP_VENDOR_NXP_GET_SET_RCP_FREQUENCY_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10E),
+    SPINEL_CMD_VENDOR_NXP_MFG  = (SPINEL_CMD_VENDOR__BEGIN + 0x3FF),
+
     SPINEL_PROP_VENDOR__END   = 0x4000,
 
     SPINEL_PROP_VENDOR_ESP__BEGIN = (SPINEL_PROP_VENDOR__BEGIN + 0),
diff --git a/src/lib/spinel/spinel_interface.hpp b/src/lib/spinel/spinel_interface.hpp
index 344de7e43..64105e5bb 100644
--- a/src/lib/spinel/spinel_interface.hpp
+++ b/src/lib/spinel/spinel_interface.hpp
@@ -128,7 +128,7 @@ public:
      * @returns   Bus speed in bits/second.
      *
      */
-    virtual uint32_t GetBusSpeed(void) const = 0;
+    virtual uint32_t GetBusSpeed(void) = 0;
 
     /**
      * Hardware resets the RCP.
diff --git a/src/ncp/ncp_spi.cpp b/src/ncp/ncp_spi.cpp
index 1cd4f9aab..7dd4da952 100644
--- a/src/ncp/ncp_spi.cpp
+++ b/src/ncp/ncp_spi.cpp
@@ -340,9 +340,11 @@ void NcpSpi::PrepareTxFrame(void)
     }
 }
 
+#define OT_PLATFORM_RING_BUFFER_TAG (0xAA)
+
 void NcpSpi::HandleRxFrame(void)
 {
-    SpiFrame recvFrame(mReceiveFrame);
+    SpiFrame recvFrame( (mReceiveFrame[4] == OT_PLATFORM_RING_BUFFER_TAG) ? (uint8_t*)(*(uint32_t*)mReceiveFrame) : mReceiveFrame );
     SpiFrame sendFrame(mSendFrame);
 
     // Pass the received frame to base class to process.
diff --git a/src/posix/main.c b/src/posix/main.c
index 0f989dfb5..2e0927092 100644
--- a/src/posix/main.c
+++ b/src/posix/main.c
@@ -70,6 +70,15 @@
 
 #include "lib/platform/reset_util.h"
 
+extern otError ProcessIRConfig(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessIRCmd(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessGetSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessMfgCommands(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessGetSetCcaCfg(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessGetFwVersion(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+extern otError ProcessGetSetSpiFrequency(void *aContext, uint8_t aArgsLength, char *aArgs[]);
+
 /**
  * Initializes NCP app.
  *
@@ -357,6 +366,14 @@ static const otCliCommand kCommands[] = {
     {"exit", ProcessExit},
 #endif
     {"netif", ProcessNetif},
+    {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+    {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+    {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+    {"txpwrlimit", ProcessGetSetTxPowerLimit}, //=> Set TX power limit for 15.4
+    {"mfgcmd", ProcessMfgCommands}, //=> Generic VSC for MFG RF commands
+    {"ccacfg", ProcessGetSetCcaCfg}, //=> Set/Get CCA configuration for 15.4 CCA Before Tx operation
+    {"fwversion", ProcessGetFwVersion}, //=> Get firmware version for 15.4
+    {"spifreq", ProcessGetSetSpiFrequency}  //=> Get/Set SPI frequency supported by RCP
 };
 
 int main(int argc, char *argv[])
diff --git a/src/posix/platform/daemon.cpp b/src/posix/platform/daemon.cpp
index e399de1c0..b5ac0bbc6 100644
--- a/src/posix/platform/daemon.cpp
+++ b/src/posix/platform/daemon.cpp
@@ -40,6 +40,7 @@
 #include <unistd.h>
 
 #include <openthread/cli.h>
+#include <openthread/thread.h>
 
 #include "cli/cli_config.h"
 #include "common/code_utils.hpp"
@@ -72,6 +73,632 @@ void GetFilename(Filename &aFilename, const char *aPattern)
 
 } // namespace
 
+//Vendor Specific commands
+extern "C"
+{
+#define MFG_CMD_ACTION_GET 0
+#define MFG_CMD_ACTION_SET 1
+
+#define MFG_CMD_GET_SET_CHANNEL 0x0b      // 11
+#define MFG_CMD_GET_SET_TXPOWER 0x0f      // 15
+#define MFG_CMD_CONTINUOUS_TX 0x11        // 17
+#define MFG_CMD_GET_SET_PAYLOAD_SIZE 0x14 // 20
+#define MFG_CMD_GET_RX_RESULT 0x1f        // 31
+#define MFG_CMD_START_RX_TEST 0x20        // 32
+#define MFG_CMD_BURST_TX 0x21             // 33
+#define MFG_CMD_DUTY_CYCLE_TX 0x23        // 35
+#define MFG_CMD_GET_SET_CCA_THRESHOLD  0x2F   // 47
+#define MFG_CMD_CONTINOUS_CCA_TEST 0X31   //49
+#define MFG_CMD_GET_CCA_STATUS 0x32       //50
+#define MFG_CMD_CONTINOUS_ED_TEST 0x37    //55
+#define MFG_CMD_GET_ED_VALUE    0x38      //56
+#define MFG_CMD_PHY_TX_TEST_PSDU 0x39     //57
+#define MFG_CMD_PHY_RX_TX_ACK_TEST 0x3A   //58
+#define MFG_CMD_SET_GENERIC_PARAM 0x3B    //59
+
+#define MAX_VERSION_STRING_SIZE 128 //< Max size of version string
+
+static uint8_t mfgEnable = 0;
+
+// 15.4_INDEPENDENT_RESET
+otError ProcessIRConfig(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    //syslog(LOG_INFO, "ProcessIRConfig");
+
+    if( aArgsLength == 1 )
+    {
+        uint16_t mode = (uint16_t)atoi(aArgs[0]);
+        //syslog(LOG_INFO, "-> mode %s", mode==0 ? "Disable IR":(mode==1 ?("OOB IR"):"InBand IR"));
+        if( mode < 3 )
+        {
+            otPlatRadioSetIRConfig((otInstance*)aContext, mode);
+            //syslog(LOG_INFO, "ProcessIRConfig DONE");
+        }
+    }
+    else
+    {
+        //syslog(LOG_INFO, "ProcessIRConfig FAILED!");
+    }
+
+    return OT_ERROR_NONE;
+}
+
+otError ProcessIRCmd(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    OT_UNUSED_VARIABLE(aArgsLength);
+    OT_UNUSED_VARIABLE(aArgs);
+    //syslog(LOG_INFO, "ProcessIRCmd");
+    otPlatRadioSetIRCmd((otInstance*)aContext);
+    //syslog(LOG_INFO, "ProcessIRCmd DONE");
+
+    return OT_ERROR_NONE;
+}
+
+otError ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    otError error = OT_ERROR_INVALID_ARGS;
+
+    if( aArgsLength == 1 )
+    {
+        otExtAddress addr;
+        char        *hex  = *aArgs;
+
+        //syslog(LOG_INFO, "+ SetEui64 %s (len %d)", *aArgs, (uint32_t)strlen(*aArgs));
+
+        if( (hex[1] == 'x') && (strlen(*aArgs) == 18) )
+        {
+            error = OT_ERROR_NONE;
+
+            hex = hex + 2;
+
+            for(uint32_t i = 0; (i < 8) && (error == OT_ERROR_NONE); i++)
+            {
+                addr.m8[i] = 0;
+                for(uint32_t k = 0; k < 2; k++)
+                {
+                    // get current character then increment
+                    uint8_t byte = *hex++;
+                    // transform hex character to the 4bit equivalent number, using the ascii table indexes
+                    if (byte >= '0' && byte <= '9')
+                        byte = byte - '0';
+                    else if (byte >= 'a' && byte <='f')
+                        byte = byte - 'a' + 10;
+                    else if (byte >= 'A' && byte <='F')
+                        byte = byte - 'A' + 10;
+                    else
+                    {
+                        error = OT_ERROR_FAILED;
+                        break;
+                    }
+                    // shift 4 to make space for new digit, and add the 4 bits of the new digit
+                    addr.m8[i] = (addr.m8[i] << 4) | (byte & 0xF);
+                }
+            }
+
+            if( error == OT_ERROR_NONE )
+            {
+                error = otPlatRadioSetIeeeEui64((otInstance*)aContext, (const otExtAddress*)&addr);
+            }
+
+            if( error != OT_ERROR_NONE )
+            {
+                //syslog(LOG_INFO, "- SetEui64 Failed (%#x)", error);
+            }
+            else
+            {
+                //syslog(LOG_INFO, "- SetEui64 SUCCESS");
+            }
+        }
+        else
+        {
+            //syslog(LOG_INFO, "- SetEui64 invalid input arg (0x....?) !");
+        }
+    }
+    else
+    {
+        //syslog(LOG_INFO, "- SetEui64 FAILED !");
+    }
+
+    return error;
+}
+
+otError ProcessGetSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+
+    otError error = OT_ERROR_INVALID_ARGS;
+    uint8_t txPowerLimit = 0;
+
+    //syslog(LOG_INFO, "SetTxPowerLimit");
+
+    if( aArgsLength == 1 ) // set tx power limit
+    {
+        txPowerLimit = (uint8_t)atoi(aArgs[0]);
+        if((txPowerLimit>=1)&&(txPowerLimit<=44)){
+            //syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
+        }else{
+            //syslog(LOG_INFO, "-> txPowerLimit : default value");
+        }
+        otPlatRadioSetTxPowerLimit((otInstance*)aContext, txPowerLimit);
+        //syslog(LOG_INFO, "SetTxPowerLimit DONE");
+        error = OT_ERROR_NONE;
+    }
+    else if ( aArgsLength == 0 ) // get tx power limit
+    {
+        otPlatRadioGetTxPowerLimit((otInstance*)aContext, &txPowerLimit);
+
+        // Add value in syslog
+        //syslog(LOG_INFO, "TX power Value value : %d", txPowerLimit);
+
+        // Print value as ot-cli output
+        otCliOutputFormat("%d\r\n", txPowerLimit);
+        error = OT_ERROR_NONE;
+    }
+    else
+    {
+        //syslog(LOG_INFO, "SetTxPowerLimit FAILED! Invalid input arg");
+    }
+
+    return error;
+}
+
+ otError ProcessMfgGetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength)
+{
+    otError error = OT_ERROR_INVALID_ARGS;
+    uint8_t outputLen = 0;
+    uint8_t payload[12] = {11};
+    uint8_t payloadLen = 12;
+
+    if(aArgsLength == 1)
+    {
+        payload[1] = cmdId;
+        payload[2] = MFG_CMD_ACTION_GET;
+
+        otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+
+        if((outputLen >= 5) && (payload[3] == 0))
+        {
+            if(cmdId == MFG_CMD_GET_SET_TXPOWER)
+            {
+                otCliOutputFormat("%d\r\n", ((int8_t)payload[4])/2);
+            }
+            else
+            {
+                otCliOutputFormat("%d\r\n", (int8_t)payload[4]);
+            }
+            error = OT_ERROR_NONE;
+        }
+        else{
+            error = OT_ERROR_FAILED;
+        }
+    }
+
+    return error;
+}
+
+ otError ProcessMfgSetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength, char *aArgs[], int8_t min, int8_t max)
+{
+    otError error = OT_ERROR_INVALID_ARGS;
+    uint8_t outputLen = 0;
+    uint8_t payload[12] = {11};
+    uint8_t payloadLen = 12;
+    int8_t setValue = 0;
+
+    if(aArgsLength == 2)
+    {
+        setValue = (int8_t)atoi(aArgs[1]);
+        if((setValue >= min) && (setValue <= max))
+        {
+            payload[1] = cmdId;
+            payload[2] = MFG_CMD_ACTION_SET;
+            if(cmdId == MFG_CMD_GET_SET_TXPOWER)
+            {
+                payload[4] = ((uint8_t)setValue) << 1; // convert dBm to half dBm
+            }
+            else
+            {
+                payload[4] = (uint8_t)setValue;
+            }
+
+            otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+
+            if((outputLen >= 4) && (payload[3] == 0))
+            {
+                error = OT_ERROR_NONE;
+            }
+            else
+            {
+                error = OT_ERROR_FAILED;
+            }
+        }
+    }
+
+    return error;
+}
+
+otError ProcessMfgCommands(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    uint8_t payload[12] = {11};
+    uint8_t payloadLen = 12;
+    uint8_t outputLen = 0;
+    otError error = OT_ERROR_INVALID_ARGS;
+    uint8_t cmdId, idx;
+
+    if(aArgsLength == 1)
+    {
+        cmdId = (uint8_t)atoi(aArgs[0]);
+        if((cmdId == 0)||(cmdId == 1))
+        {
+            mfgEnable = cmdId;
+            //syslog(LOG_INFO, "MFG command SUCCESS");
+            return OT_ERROR_NONE;
+        }
+    }
+
+    if(mfgEnable == 0)
+    {
+        //syslog(LOG_INFO, "MFG command not enabled");
+        otCliOutputFormat("MFG command not enabled. to enable it : mfgcmd 1\r\n");
+        return OT_ERROR_NONE;
+    }
+
+    if ((aArgsLength > 0) && (mfgEnable == 1))
+    {
+        cmdId = (uint8_t)atoi(aArgs[0]);
+
+        switch (cmdId)
+        {
+        case MFG_CMD_GET_SET_CHANNEL: // get channel
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength);
+            break;
+
+        case MFG_CMD_GET_SET_CHANNEL + 1: // set channel
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength, aArgs, 11, 26);
+            break;
+
+        case MFG_CMD_GET_SET_TXPOWER: // get txpower
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength);
+            break;
+
+        case MFG_CMD_GET_SET_TXPOWER + 1: // set txpower
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength, aArgs, -20, 22);
+            break;
+
+        case MFG_CMD_CONTINUOUS_TX:
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_CONTINUOUS_TX, aArgsLength, aArgs, 0, 1);
+            break;
+
+        case MFG_CMD_GET_SET_PAYLOAD_SIZE: // get
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength);
+            break;
+
+        case MFG_CMD_GET_SET_PAYLOAD_SIZE + 1: // set
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength, aArgs, 17, 116);
+            break;
+
+        case MFG_CMD_GET_RX_RESULT:
+        {
+            if(aArgsLength == 1)
+            {
+                payload[1] = MFG_CMD_GET_RX_RESULT;
+                payload[2] = MFG_CMD_ACTION_GET;
+                otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                if(outputLen >= 11)
+                {
+                    otCliOutputFormat("status : %d\r\n", payload[4]);
+                    otCliOutputFormat("rx_pkt_count : %d\r\n", payload[5]|(payload[6]<<8));
+                    otCliOutputFormat("total_pkt_count : %d\r\n", payload[7]|(payload[8]<<8));
+                    otCliOutputFormat("rssi : %d\r\n",(int8_t)payload[9]);
+                    otCliOutputFormat("lqi : %d\r\n", payload[10]);
+                    error = OT_ERROR_NONE;
+                }
+                else{
+                    error = OT_ERROR_FAILED;
+                }
+            }
+        }
+        break;
+
+        case MFG_CMD_START_RX_TEST:
+        {
+            if(aArgsLength == 1)
+            {
+                payload[1] = MFG_CMD_START_RX_TEST;
+                otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                error = OT_ERROR_NONE;
+            }
+        }
+        break;
+
+        case MFG_CMD_BURST_TX:
+        {
+            uint8_t mode = 0, gap = 0;
+            if(aArgsLength == 3)
+            {
+                mode = (uint8_t)atoi(aArgs[1]);
+                gap = (uint8_t)atoi(aArgs[2]);
+                if((mode < 8) && (gap > 5))
+                {
+                    payload[1] = MFG_CMD_BURST_TX;
+                    payload[4] = mode;
+                    payload[5] = gap;
+                    otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                    error = OT_ERROR_NONE;
+                }
+            }
+        }
+        break;
+
+        case MFG_CMD_DUTY_CYCLE_TX:
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_DUTY_CYCLE_TX, aArgsLength, aArgs, 0, 1);
+            break;
+
+        case MFG_CMD_GET_SET_CCA_THRESHOLD: // get
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength);
+            break;
+
+        case MFG_CMD_GET_SET_CCA_THRESHOLD + 1: // set
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength, aArgs, -110, 0);
+            break;
+
+        case MFG_CMD_CONTINOUS_CCA_TEST:
+        {
+            if(aArgsLength == 3)
+            {
+                payload[1] = MFG_CMD_CONTINOUS_CCA_TEST;
+                payload[2] = MFG_CMD_ACTION_SET;
+                payload[4] = (uint8_t)atoi(aArgs[1]); // enable
+                payload[5] = (uint8_t)atoi(aArgs[2]); // CCA Mode
+                if((payload[4] < 2) && (payload[5] < 4))
+                {
+                    otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                    if((outputLen >= 4) && (payload[3] == 0))
+                    {
+                        error = OT_ERROR_NONE;
+                    }
+                    else{
+                        error = OT_ERROR_FAILED;
+                    }
+                }
+            }
+        }
+        break;
+
+        case MFG_CMD_GET_CCA_STATUS: // get
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_CCA_STATUS, aArgsLength);
+            break;
+
+        case MFG_CMD_CONTINOUS_ED_TEST:
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_CONTINOUS_ED_TEST, aArgsLength, aArgs, 0, 1);
+            break;
+
+        case MFG_CMD_GET_ED_VALUE:
+            error = ProcessMfgGetInt8((otInstance*)aContext, MFG_CMD_GET_ED_VALUE, aArgsLength);
+            break;
+
+        case MFG_CMD_PHY_TX_TEST_PSDU:
+        {
+            uint8_t count_opt, gap, ackEnable;
+            if(aArgsLength == 4)
+            {
+                payload[1]  = MFG_CMD_PHY_TX_TEST_PSDU;
+                payload[2]  = MFG_CMD_ACTION_SET;
+
+                count_opt = (uint8_t)atoi(aArgs[1]);
+                gap       = (uint8_t)atoi(aArgs[2]);
+                ackEnable = (uint8_t)atoi(aArgs[3]);
+                if((count_opt < 8) && (gap > 5) && (ackEnable < 2))
+                {
+                    payload[4]  = count_opt;
+                    payload[5]  = gap;
+                    payload[6]  = ackEnable;
+                    otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                    error = OT_ERROR_NONE;
+                }
+            }
+        }
+        break;
+
+        case MFG_CMD_PHY_RX_TX_ACK_TEST:
+            error = ProcessMfgSetInt8((otInstance*)aContext, MFG_CMD_PHY_RX_TX_ACK_TEST, aArgsLength, aArgs, 0, 1);
+            break;
+
+        case MFG_CMD_SET_GENERIC_PARAM:
+        {
+            uint16_t panid, destaddr, srcaddr;
+            if(aArgsLength == 5)
+            {
+                panid       = (uint16_t)strtol(aArgs[2], NULL, 16);
+                destaddr    = (uint16_t)strtol(aArgs[3], NULL, 16);
+                srcaddr     = (uint16_t)strtol(aArgs[4], NULL, 16);
+
+                payload[1]  = MFG_CMD_SET_GENERIC_PARAM;
+                payload[2]  = MFG_CMD_ACTION_SET;
+                payload[4]  = (uint8_t) atoi(aArgs[1]); // SEQ_NUM
+                payload[5]  = (uint8_t) (panid & 0xFF); // PAN ID LSB
+                payload[6]  = (uint8_t) ((panid >> 8) & 0xFF); // PAN ID MSB
+                payload[7]  = (uint8_t) (destaddr & 0xFF); // DEST ADDR LSB
+                payload[8]  = (uint8_t) ((destaddr >> 8) & 0xFF); // DEST ADDR MSB
+                payload[9]  = (uint8_t) (srcaddr & 0xFF); // SRC ADDR LSB
+                payload[10] = (uint8_t) ((srcaddr >> 8) & 0xFF); // SRC ADDR MSB
+
+                otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t*)payload, payloadLen, &outputLen);
+                error = OT_ERROR_NONE;
+            }
+        }
+        break;
+
+        default:
+            error = OT_ERROR_NOT_IMPLEMENTED;
+            break;
+        }
+    }
+
+    //HANDLE ERRORS
+    if(error == OT_ERROR_NONE)
+    {
+        //syslog(LOG_INFO, "MFG command SUCCESS");
+    }
+    else if(aArgsLength == payloadLen)
+    {
+        // If user passed all the payload, this means this is a direct message for the RCP.
+        // Send it and print the return results.
+        for(idx = 0; idx < payloadLen; idx++)
+        {
+            payload[idx] = (uint8_t)atoi(aArgs[idx]);
+        }
+        otPlatRadioMfgCommand((otInstance*)aContext, (uint8_t *)payload, payloadLen, &outputLen);
+        for(idx = 0; idx < outputLen; idx++)
+        {
+            otCliOutputFormat("%d ", payload[idx]);
+        }
+        otCliOutputFormat("\r\n");
+        error = OT_ERROR_NONE;
+        //syslog(LOG_INFO, "MFG command SUCCESS");
+    }
+    else if(error == OT_ERROR_INVALID_ARGS)
+    {
+        //syslog(LOG_INFO, "MFG command Invalid parameter");
+        //otCliOutputFormat("INVALID PARAMETER\r\n");
+    }
+    else if(error == OT_ERROR_NOT_IMPLEMENTED)
+    {
+        //syslog(LOG_INFO, "MFG command not implemented");
+        otCliOutputFormat("NOT IMPLEMENTED\r\n");
+    }
+    else
+    {
+        //syslog(LOG_INFO, "MFG command FAILED");
+        otCliOutputFormat("FAILED\r\n");
+    }
+
+    return error;
+}
+
+otError ProcessGetSetCcaCfg(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    otCCAModeConfig aCcaCfg;
+    //syslog(LOG_INFO, "SetCcaConfig");
+
+    if( aArgsLength == 4 ) // set cca configuration
+    {
+        aCcaCfg.mCcaMode            = (uint8_t)strtol(aArgs[0], NULL, 16);
+        aCcaCfg.mCca1Threshold      = (uint8_t)strtol(aArgs[1], NULL, 16);
+        aCcaCfg.mCca2CorrThreshold  = (uint8_t)strtol(aArgs[2], NULL, 16);
+        aCcaCfg.mCca2MinNumOfCorrTh = (uint8_t)strtol(aArgs[3], NULL, 16);
+        if ((((aCcaCfg.mCcaMode >= 1) && (aCcaCfg.mCcaMode <= 4)) || (aCcaCfg.mCcaMode == 0xFF)) &&
+           (aCcaCfg.mCca2MinNumOfCorrTh <= 6) ){
+            otPlatRadioCcaConfigValue((otInstance*)aContext, &aCcaCfg, 0x1);
+            //syslog(LOG_INFO, "SetCcaConfig DONE");
+        }
+    }
+    else if ( aArgsLength == 0 ) // get cca configuration
+    {
+        otPlatRadioCcaConfigValue((otInstance*)aContext, &aCcaCfg, 0x0);
+
+        // Add value in syslog
+        //syslog(LOG_INFO, "CCA Configuration:\r\n");
+        //syslog(LOG_INFO, "CCA Mode type: CCA1=0x01, CCA2=0x02, CCA3=0x03[CCA1 AND CCA2], CCA3=0x04[CCA1 OR CCA2], NoCCA=0xFF: 0x%x\r\n", aCcaCfg.mCcaMode);
+        //syslog(LOG_INFO, "CCA1 Threshold Value : 0x%x\r\n", aCcaCfg.mCca1Threshold);
+        //syslog(LOG_INFO, "CCA2 Correlation Threshold Value : 0x%x\r\n", aCcaCfg.mCca2CorrThreshold);
+        //syslog(LOG_INFO, "CCA2 Minimim Number of Correlation Threshold Value : 0x%x\r\n", aCcaCfg.mCca2MinNumOfCorrTh);
+
+        // Print value as ot-cli output
+        otCliOutputFormat("CCA Configuration:\r\n");
+        otCliOutputFormat("CCA Mode type: CCA1=0x01, CCA2=0x02, CCA3=0x03[CCA1 AND CCA2], CCA3=0x04[CCA1 OR CCA2], NoCCA=0xFF: 0x%x\r\n", aCcaCfg.mCcaMode);
+        otCliOutputFormat("CCA1 Threshold Value : 0x%x\r\n", aCcaCfg.mCca1Threshold);
+        otCliOutputFormat("CCA2 Correlation Threshold Value : 0x%x\r\n", aCcaCfg.mCca2CorrThreshold);
+        otCliOutputFormat("CCA2 Minimim Number of Correlation Threshold Value : 0x%x\r\n", aCcaCfg.mCca2MinNumOfCorrTh);
+    }
+    else
+    {
+        //syslog(LOG_INFO, "ccacfg FAILED! Invalid input arg\r\nFormat: ccacfg <CcaMode> <Cca1Threshold> <Cca2CorrThreshold> <Cca2MinNumOfCorrTh>\r\nCcaMode: CCA Mode type [CCA1=0x01, CCA2=0x02, CCA3=0x03[CCA1 AND CCA2], CCA3=0x04[CCA1 OR CCA2], NoCCA=0xFF]\r\nCca1Threshold[1Byte Hex value]: Energy threshold for CCA Mode1\r\nCca2CorrThreshold[1Byte Hex value]: CCA Mode 2 Correlation Threshold\r\nCca2MinNumOfCorrTh: [0 to 6]\r\n");
+        otCliOutputFormat("ccacfg FAILED! Invalid input arg\r\nFormat: ccacfg <CcaMode> <Cca1Threshold> <Cca2CorrThreshold> <Cca2MinNumOfCorrTh>\r\nCcaMode: CCA Mode type [CCA1=0x01, CCA2=0x02, CCA3=0x03[CCA1 AND CCA2], CCA3=0x04[CCA1 OR CCA2], NoCCA=0xFF]\r\nCca1Threshold[1Byte Hex value]: Energy threshold for CCA Mode1\r\nCca2CorrThreshold[1Byte Hex value]: CCA Mode 2 Correlation Threshold\r\nCca2MinNumOfCorrTh: [0 to 6]\r\n");
+    }
+
+    return OT_ERROR_NONE;
+}
+
+otError ProcessGetFwVersion(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    OT_UNUSED_VARIABLE(aArgs);
+
+    if ( aArgsLength == 0 )
+    {
+        const char version[MAX_VERSION_STRING_SIZE] = {0};
+        otPlatRadioGetFwVersionString((otInstance*)aContext, version, MAX_VERSION_STRING_SIZE);
+        otCliOutputFormat("%s\r\n", version);
+    }
+    else
+    {
+        //syslog(LOG_INFO, "GetFwVersion FAILED! Invalid input arg");
+    }
+    return OT_ERROR_NONE;
+}
+
+otError ProcessGetSetSpiFrequency(void *aContext, uint8_t aArgsLength, char *aArgs[])
+{
+    OT_UNUSED_VARIABLE(aArgs);
+
+    if ( aArgsLength == 0 )
+    {
+        uint32_t speed = otPlatRadioGetBusSpeed((otInstance*)aContext);
+
+        switch(speed)
+        {
+            case 1: //OT_RADIO_HIGH_BUS_SPEED
+                otCliOutputFormat("Get => RCP supports SPI Bus Speed until 10MHz\r\n");
+            break;
+            case 2: //OT_RADIO_FULL_BUS_SPEED
+                otCliOutputFormat("Get => RCP supports SPI Bus Speed > 10MHz\r\n");
+            break;
+            case 0: //OT_RADIO_DEFAULT_BUS_SPEED
+            default:
+                otCliOutputFormat("Get => RCP supports SPI Bus Speed until 4MHz\r\n");
+            break;
+        }
+    }
+    else if ( aArgsLength == 1 )
+    {
+        uint32_t speed = (uint32_t)atoi(aArgs[0]);
+
+        if( (speed >= 10000) && (speed <= 20000000) )
+        {
+            if( otThreadGetDeviceRole((otInstance*)aContext) == OT_DEVICE_ROLE_DISABLED )
+            {
+                if( otPlatRadioSetBusSpeed((otInstance*)aContext, speed) != OT_ERROR_NONE )
+                {
+                    otCliOutputFormat("Get/Set SpiFrequency FAILED! Invalid input <speed %d>\n", speed);
+                }
+            }
+            else
+            {
+                otCliOutputFormat("Get/Set SpiFrequency FAILED! Invalid STATE - %s -\n", otThreadDeviceRoleToString(otThreadGetDeviceRole((otInstance*)aContext)));
+            }
+        }
+        else
+        {
+            otCliOutputFormat("Set SpiFrequency FAILED! Invalid speed range - required [10000 (10kHz) : 10000000 (10MHz)]>\n");
+        }
+    }
+    else
+    {
+        otCliOutputFormat("Get/Set SpiFrequency FAILED! Invalid input <speed>\n");
+    }
+    return OT_ERROR_NONE;
+}
+
+static const otCliCommand kCommands[] = {
+    {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+    {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+    {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+    {"txpwrlimit", ProcessGetSetTxPowerLimit}, //=> Set TX power limit for 15.4
+    {"mfgcmd", ProcessMfgCommands}, //=> Generic VSC for MFG RF commands
+    {"ccacfg", ProcessGetSetCcaCfg}, //=> Set/Get CCA configuration for 15.4 CCA Before Tx operation
+    {"fwversion", ProcessGetFwVersion}, //=> Get firmware version for 15.4
+    {"spifreq", ProcessGetSetSpiFrequency}  //=> Get/Set SPI frequency supported by RCP
+};
+} //extern "C"
+
 int Daemon::OutputFormatV(const char *aFormat, va_list aArguments)
 {
     static constexpr char truncatedMsg[] = "(truncated ...)";
@@ -251,6 +878,8 @@ void Daemon::SetUp(void)
         },
         this);
 
+    otCliSetUserCommands(kCommands, OT_ARRAY_LENGTH(kCommands), gInstance);
+
     Mainloop::Manager::Get().Add(*this);
 
 exit:
diff --git a/src/posix/platform/hdlc_interface.cpp b/src/posix/platform/hdlc_interface.cpp
index b1fb297f8..d3e5a215c 100644
--- a/src/posix/platform/hdlc_interface.cpp
+++ b/src/posix/platform/hdlc_interface.cpp
@@ -176,7 +176,11 @@ exit:
 
 HdlcInterface::~HdlcInterface(void) { Deinit(); }
 
-void HdlcInterface::Deinit(void) { CloseFile(); }
+void HdlcInterface::Deinit(void)
+{
+    otLogDebgPlat("Deinit: close %s", (mSockFd >= 0)?("Radio "):(""));
+    CloseFile();
+}
 
 void HdlcInterface::Read(void)
 {
diff --git a/src/posix/platform/hdlc_interface.hpp b/src/posix/platform/hdlc_interface.hpp
index 04266a667..33dd90083 100644
--- a/src/posix/platform/hdlc_interface.hpp
+++ b/src/posix/platform/hdlc_interface.hpp
@@ -136,7 +136,16 @@ public:
      * @returns   Bus speed in bits/second.
      *
      */
-    uint32_t GetBusSpeed(void) const { return mBaudRate; }
+    uint32_t GetBusSpeed(void) { return mBaudRate; }
+
+    /**
+     * This method sets the bus speed between the host and the radio.
+     *
+     * @retval  OT_ERROR_NONE           Successfully set the spi frequency.
+     * @retval  OT_ERROR_NOT_IMPLEMENTED.
+     *
+     */
+    otError SetBusSpeed(uint32_t aSpeed) { OT_UNUSED_VARIABLE(aSpeed); return OT_ERROR_NOT_IMPLEMENTED; }
 
     /**
      * Hardware resets the RCP.
diff --git a/src/posix/platform/include/openthread/openthread-system.h b/src/posix/platform/include/openthread/openthread-system.h
index e3b02fc5a..23a44d4ca 100644
--- a/src/posix/platform/include/openthread/openthread-system.h
+++ b/src/posix/platform/include/openthread/openthread-system.h
@@ -64,7 +64,7 @@ enum
     OT_PLATFORM_CONFIG_SPI_DEFAULT_ALIGN_ALLOWANCE =
         16, ///< Default maximum number of 0xFF bytes to clip from start of MISO frame.
     OT_PLATFORM_CONFIG_SPI_DEFAULT_SMALL_PACKET_SIZE =
-        32,                                ///< Default smallest SPI packet size we can receive in a single transaction.
+        48,                                ///< Default smallest SPI packet size we can receive in a single transaction.
     OT_PLATFORM_CONFIG_MAX_RADIO_URLS = 2, ///< Max number of Radio URLs.
 };
 
diff --git a/src/posix/platform/openthread-core-posix-config.h b/src/posix/platform/openthread-core-posix-config.h
index adff0060f..fddcbae38 100644
--- a/src/posix/platform/openthread-core-posix-config.h
+++ b/src/posix/platform/openthread-core-posix-config.h
@@ -184,7 +184,7 @@
  *
  */
 #ifndef OPENTHREAD_CONFIG_MLE_MAX_CHILDREN
-#define OPENTHREAD_CONFIG_MLE_MAX_CHILDREN 64
+#define OPENTHREAD_CONFIG_MLE_MAX_CHILDREN 128
 #endif
 
 /**
diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
index c9d613395..adad840b6 100644
--- a/src/posix/platform/radio.cpp
+++ b/src/posix/platform/radio.cpp
@@ -814,6 +814,12 @@ uint32_t otPlatRadioGetBusSpeed(otInstance *aInstance)
     return sRadioSpinel.GetBusSpeed();
 }
 
+otError otPlatRadioSetBusSpeed(otInstance *aInstance, uint32_t aSpeed)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.SetBusSpeed(aSpeed);
+}
+
 #if OPENTHREAD_CONFIG_MAC_CSL_RECEIVER_ENABLE || OPENTHREAD_CONFIG_MAC_CSL_TRANSMITTER_ENABLE
 uint8_t otPlatRadioGetCslAccuracy(otInstance *aInstance)
 {
@@ -904,6 +910,61 @@ otError otPlatRadioReceiveAt(otInstance *aInstance, uint8_t aChannel, uint32_t a
     return OT_ERROR_NOT_IMPLEMENTED;
 }
 
+void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CONFIG, SPINEL_DATATYPE_UINT16_S, mode));
+}
+
+void otPlatRadioSetIRCmd(otInstance *aInstance)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CMD, SPINEL_DATATYPE_UINT16_S));
+}
+
+otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    otExtAddress addr;
+
+    for (size_t i = 0; i < sizeof(addr); i++)
+    {
+        addr.m8[i] = aIeeeEui64->m8[sizeof(addr) - 1 - i];
+    }
+
+    return sRadioSpinel.SetIeeeEui64(*aIeeeEui64);
+}
+
+otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
+}
+
+otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.GetTxPowerLimit(*txPowerLimit);
+}
+
+otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.MfgCmd(payload, payloadLenIn, *payloadLenOut);
+}
+
+otError otPlatRadioCcaConfigValue(otInstance *aInstance, otCCAModeConfig *aOtCCAModeConfig, uint8_t aSetValue)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.CcaConfigValue(*aOtCCAModeConfig, aSetValue);
+}
+
+otError otPlatRadioGetFwVersionString(otInstance *aInstance, const char *fwVersion, uint8_t fwVersionLen)
+{
+    OT_UNUSED_VARIABLE(aInstance);
+    return sRadioSpinel.GetFwVersion(fwVersion, fwVersionLen);
+}
+
 const otRadioSpinelMetrics *otSysGetRadioSpinelMetrics(void) { return sRadioSpinel.GetRadioSpinelMetrics(); }
 
 const otRcpInterfaceMetrics *otSysGetRcpInterfaceMetrics(void)
diff --git a/src/posix/platform/spi_interface.cpp b/src/posix/platform/spi_interface.cpp
index c8a7f0ce7..3ca285810 100644
--- a/src/posix/platform/spi_interface.cpp
+++ b/src/posix/platform/spi_interface.cpp
@@ -78,6 +78,7 @@ SpiInterface::SpiInterface(ReceiveFrameCallback aCallback, void *aCallbackContex
     , mDidPrintRateLimitLog(false)
     , mSpiSlaveDataLen(0)
     , mDidRxFrame(false)
+    , mSpiRxDiscard(0)
 {
 }
 
@@ -88,6 +89,7 @@ void SpiInterface::ResetStates(void)
     mSpiTxPayloadSize     = 0;
     mDidPrintRateLimitLog = false;
     mSpiSlaveDataLen      = 0;
+    mSpiRxDiscard    = 0;
     memset(mSpiTxFrameBuffer, 0, sizeof(mSpiTxFrameBuffer));
     memset(&mInterfaceMetrics, 0, sizeof(mInterfaceMetrics));
     mInterfaceMetrics.mRcpInterfaceType = OT_POSIX_RCP_BUS_SPI;
@@ -196,6 +198,7 @@ SpiInterface::~SpiInterface(void) { Deinit(); }
 
 void SpiInterface::Deinit(void)
 {
+    otLogDebgPlat("Deinit: close %s%s%s", (mSpiDevFd >= 0)?("SpiDev "):(""), (mResetGpioValueFd >= 0)?("ResetGpio "):(""), (mIntGpioValueFd >= 0)?("IntGpio "):(""));
     if (mSpiDevFd >= 0)
     {
         close(mSpiDevFd);
@@ -257,10 +260,11 @@ int SpiInterface::SetupGpioEvent(int         aFd,
 
 void SpiInterface::SetGpioValue(int aFd, uint8_t aValue)
 {
-    struct gpiohandle_data data;
-
-    data.values[0] = aValue;
-    VerifyOrDie(ioctl(aFd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) != -1, OT_EXIT_ERROR_ERRNO);
+    OT_UNUSED_VARIABLE(aFd);
+    OT_UNUSED_VARIABLE(aValue);
+    // struct gpiohandle_data data;
+    // data.values[0] = aValue;
+    // VerifyOrDie(ioctl(aFd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) != -1, OT_EXIT_ERROR_ERRNO);
 }
 
 uint8_t SpiInterface::GetGpioValue(int aFd)
@@ -537,6 +541,7 @@ otError SpiInterface::PushPullSpi(void)
             mInterfaceMetrics.mTransferredGarbageFrameCount++;
             mSpiTxRefusedCount++;
             mSpiSlaveDataLen = 0;
+            mSpiRxDiscard    = 0;
 
             otLogWarnPlat("Garbage in header : %02X %02X %02X %02X %02X", spiRxFrame[0], spiRxFrame[1], spiRxFrame[2],
                           spiRxFrame[3], spiRxFrame[4]);
@@ -559,21 +564,35 @@ otError SpiInterface::PushPullSpi(void)
         // Handle received packet, if any.
         if ((mSpiSlaveDataLen != 0) && (mSpiSlaveDataLen <= txFrame.GetHeaderAcceptLen()))
         {
-            mInterfaceMetrics.mRxFrameByteCount += mSpiSlaveDataLen;
-            mSpiSlaveDataLen = 0;
-            mInterfaceMetrics.mRxFrameCount++;
-            successfulExchanges++;
-
-            // Set the skip length to skip align bytes and SPI frame header.
-            SuccessOrExit(error = mRxFrameBuffer.SetSkipLength(skipAlignAllowanceLength + kSpiFrameHeaderSize));
-            // Set the received frame length.
-            SuccessOrExit(error = mRxFrameBuffer.SetLength(rxFrame.GetHeaderDataLen()));
-
-            // Upper layer will free the frame buffer.
-            discardRxFrame = false;
-
-            mDidRxFrame = true;
-            mReceiveFrameCallback(mReceiveFrameContext);
+            // WAR - Discard first transaction which as transaction greater than 32 bytes with RX data available (as RCP truncated it)
+            if( (mSpiRxDiscard == 0) && (txFrame.GetHeaderAcceptLen() > mSpiSmallPacketSize) && (txFrame.GetHeaderDataLen() == txFrame.GetHeaderAcceptLen()) )
+            {
+                otLogWarnPlat("WAR RX Frame length (0x%02X) truncated (Header was 0x%02X )", txFrame.GetHeaderAcceptLen(), mSpiSlaveDataLen);
+                mSpiRxDiscard++;
+            }
+            else
+            {
+                mInterfaceMetrics.mRxFrameByteCount += mSpiSlaveDataLen;
+                mSpiSlaveDataLen = 0;
+                mInterfaceMetrics.mRxFrameCount++;
+                successfulExchanges++;
+                mSpiRxDiscard    = 0;
+
+                // Set the skip length to skip align bytes and SPI frame header.
+                SuccessOrExit(error = mRxFrameBuffer.SetSkipLength(skipAlignAllowanceLength + kSpiFrameHeaderSize));
+                // Set the received frame length.
+                SuccessOrExit(error = mRxFrameBuffer.SetLength(rxFrame.GetHeaderDataLen()));
+
+                // Upper layer will free the frame buffer.
+                discardRxFrame = false;
+
+                mDidRxFrame = true;
+                mReceiveFrameCallback(mReceiveFrameContext);
+            }
+        }
+        else if( mSpiSlaveDataLen != 0 )
+        {
+            mSpiRxDiscard++;
         }
     }
 
@@ -590,6 +609,8 @@ otError SpiInterface::PushPullSpi(void)
             mInterfaceMetrics.mTxFrameByteCount += mSpiTxPayloadSize;
 
             mSpiTxIsReady      = false;
+            // Clear tx buffer after usage
+            memset(&mSpiTxFrameBuffer[kSpiFrameHeaderSize], 0, mSpiTxPayloadSize);
             mSpiTxPayloadSize  = 0;
             mSpiTxRefusedCount = 0;
         }
@@ -659,6 +680,17 @@ void SpiInterface::UpdateFdSet(void *aMainloopContext)
             // The interrupt pin was not asserted, so we wait for the interrupt pin to be asserted by adding it to the
             // read set.
             FD_SET(mIntGpioValueFd, &context->mReadFdSet);
+
+            if (CheckInterrupt())
+            {
+                // Interrupt pin was not asserted before FD_SET
+                // but it is after.
+                // set the timeout to zero else the select will not detect the falling edge
+                // and will wait until the end of the timeout
+                timeout.tv_sec  = 0;
+                timeout.tv_usec = 0;
+                otLogDebgPlat("UpdateFdSet(): Interrupt after FD_SET.");
+            }
         }
     }
     else if (timercmp(&pollingTimeout, &timeout, <))
diff --git a/src/posix/platform/spi_interface.hpp b/src/posix/platform/spi_interface.hpp
index cd0ee2033..a663c8b22 100644
--- a/src/posix/platform/spi_interface.hpp
+++ b/src/posix/platform/spi_interface.hpp
@@ -137,8 +137,15 @@ public:
      * @returns   Bus speed in bits/second.
      *
      */
-    uint32_t GetBusSpeed(void) const { return ((mSpiDevFd >= 0) ? mSpiSpeedHz : 0); }
+    uint32_t GetBusSpeed(void) { return ((mSpiDevFd >= 0) ? mSpiSpeedHz : 0); }
 
+    /**
+     * This method returns the bus speed between the host and the radio.
+     *
+     * @returns   Bus speed in bits/second.
+     *
+     */
+    void SetBusSpeed(uint32_t aSpeed) { ((mSpiDevFd >= 0) ? mSpiSpeedHz = aSpeed : mSpiSpeedHz = 0); }
     /**
      * Hardware resets the RCP.
      *
@@ -232,6 +239,7 @@ private:
     uint16_t mSpiSlaveDataLen;
 
     bool mDidRxFrame;
+    uint32_t mSpiRxDiscard;
 
     otRcpInterfaceMetrics mInterfaceMetrics;
 
diff --git a/src/posix/platform/system.cpp b/src/posix/platform/system.cpp
index c52dea125..0b5401e07 100644
--- a/src/posix/platform/system.cpp
+++ b/src/posix/platform/system.cpp
@@ -130,6 +130,8 @@ void platformInit(otPlatformConfig *aPlatformConfig)
     platformAlarmInit(aPlatformConfig->mSpeedUpFactor, aPlatformConfig->mRealTimeSignal);
     platformRadioInit(get802154RadioUrl(aPlatformConfig));
 
+    atexit(&platformRadioDeinit);
+
     // For Dry-Run option, only init the radio.
     VerifyOrExit(!aPlatformConfig->mDryRun);
 
-- 
2.34.1

